/* Schwarze Linie Main */

#include "NXCDefs.h"
#include "HTSMUX-driver.h"

long intzeroval;
bool flag1;
bool flag2;
bool DirectionRight;
int time;
long sensorTime;
byte count;
byte SpeedLeft;
byte SpeedRight;
#define Speednorm 100
#define Schwarzwert 53
int GreenAttempts;
bool downFloor;
int Ultrasonicvalue;
int err;
long USTime;
long FFTime;
int x, y, z;
unsigned int Pod1 = 0;
unsigned int Pod2 = 0;
unsigned int Pod3 = 0;


#define ramp 70
#define stime 2000
#define Silberwert2 70
#define Silberwert3 65

int backtime = 800;
int turntime = 800;
int nigger = 0;
int evadetime = 1500;
int fortime = 3000;

void StartTiming()
{
     intzeroval = CurrentTick();
}
void StartGreenLine()
{
     sensorTime = CurrentTick();
}
void StartUS()
{
     USTime = CurrentTick();
}
long ReturnTime()
{
     return (CurrentTick() - intzeroval);
}
 void StartFF()
{
     FFTime = CurrentTick();
}
long ReturnFF()
{
     return (CurrentTick() - FFTime);
}
long ReturnSensorTime()
{
     return (CurrentTick() - sensorTime);
}

long ReturnUSTime()
{
      return (CurrentTick() - USTime);
}
void evadeLeft()
{
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 100);
}
void evadeRight()
{
      OnRev(OUT_B, 100);
      OnFwd(OUT_C, 100);
}
void DoRotations(long degrees, char pwr, int iterations)
{
  TextOut(0,LCD_LINE3,"Und nochmal");
     for(int i = 0; i < iterations; i++)
     {
         RotateMotorEx(OUT_BC, -pwr, degrees, 3,true,true);
         TextOut(0,LCD_LINE1,"Fick dich Flo");
     }
}
void LongLine()
{
     DoRotations(360, 100, 9);
}

void ShortLine()
{
    DoRotations(360, 100, 7);
}

void asyncStartAvoidCollision()
{
      Off(OUT_BC);
      OnRev(OUT_BC, 80);
      Wait(backtime);
      Off(OUT_BC);

      evadeLeft();
      Wait(turntime);
      Off(OUT_BC);

      OnFwd(OUT_BC, 80);
      Wait(evadetime);

      evadeRight();
      Wait(turntime);

      OnFwd(OUT_BC, 80);
      Wait(fortime);
      Off(OUT_BC);

      evadeRight();
      Wait(turntime);
      Off(OUT_BC);

      OnFwd(OUT_BC, 80);
      Wait(evadetime-1000);
      ClearScreen();
      while((SENSOR_2 > Schwarzwert) && (SENSOR_3 > Schwarzwert))
      {
           OnFwd(OUT_BC, 80);
           Wait(1);
      }
      Wait(200);
      evadeLeft();
      Wait(turntime);
      Off(OUT_BC);
}

void TurnLeft()
{
     SpeedLeft = 80;
     SpeedRight = -100;
     DirectionRight = false;
     StartTiming();
}

void TurnRight()
{
     SpeedLeft = -100;
     SpeedRight = 80;
     DirectionRight = true;
     StartTiming();
}

void InitSensors()
{
     SetSensorLight(IN_3);
     SetSensorLight(IN_2);
     SetSensorLowspeed(IN_1);
     SetSensorColorFull(IN_4);
     //SetSensor(S4, SENSOR_TOUCH);
     //Sensor Testen...
     if (!HTSMUXscanPorts(S1))
     {
        // Scan failed, handle the error
        TextOut(0, LCD_LINE1, "Scan failed!");
        Wait(1000);
     }
     smuxSetSensorLegoLight(msensor_S1_3, true);
}

bool isAbleToCheck()
{
     TextOut(0, LCD_LINE3, " ");
     NumOut(0, LCD_LINE3, count);
     if(count == 0)
     {
          return true;
     }
     return false;
}

void HandleCounting()
{
     ++count;
     if(count >= 50)
     {
         count = 0;
     }

}

bool ReadAccel(int &x, int &y, int &z)
{
     if(isAbleToCheck())
     {

          smuxReadSensorHTAccel(msensor_S1_2, x, y, z);
          return true;

     }

     return false;
}

bool ReadFrontTouch()
{
     if(isAbleToCheck())
     {
          return smuxReadSensorLegoTouch(msensor_S1_4);
     }
     return false;
}

int ReadBackLight()
{

     if(isAbleToCheck())
     {
          return smuxSensorLegoLightNorm(msensor_S1_3);
     }
     return 0;
}

void ReadUltrasonic()
{

    if(isAbleToCheck())
    {
        int temp = smuxSensorLegoUS(msensor_S1_1);
        if(temp == 255)
        {
          Ultrasonicvalue = 0;
        }
        else
        {
            Ultrasonicvalue = temp;
        }

    }
    else
    {
         Ultrasonicvalue = 0;
    }

}
void driveRamp()
{
     OnFwdReg(OUT_BC, 100, 2);
     Wait(10000);
}
void CheckForLongSync()
{
     if(ReadFrontTouch())
     {
         asyncStartAvoidCollision();
     }

     if(ReadAccel(x, y, z))
     {

         if(x > ramp || x < -ramp)
         {
              driveRamp();
         }
     }
     int color = SENSOR_4;
     switch(color)
     {
         case 3:
              PlayTone(5000, 20);

              GreenAttempts += 1;
              if(GreenAttempts > 5)
              {
                  StartGreenLine();
              }

         break;
         default:
              GreenAttempts = 0;
         break;

     }
     if((SENSOR_2 > 75) || (SENSOR_3 > 75))
     {
         downFloor = false;
     }

} //TODO: Add Code for Greenline
void TR45()
{
     OnRev(OUT_B, 100);
     OnFwd(OUT_C, 100);
     Wait(turntime/2);
     Off(OUT_BC);
}
void checkPods(int pod)
{
     int validcounter = 0;
     TR45();
     StartUS();
     OnFwd(OUT_BC,-30);
     while(ReturnUSTime() <= 5000)
     {
           ReadUltrasonic();
           NumOut(0,LCD_LINE2,Ultrasonicvalue);
           if(Ultrasonicvalue != 0)
           {
               validcounter++;
               switch(pod)
               {
                    case 1:  Pod1 = Pod1 + Ultrasonicvalue;
                             break;
                    case 2:  Pod2 = Pod2 + Ultrasonicvalue;
                             break;
                    case 3:  Pod3 = Pod3 + Ultrasonicvalue;
                             break;
               }
           }
     }
     switch(pod)
     {
            case 1:  Pod1 = Pod1 / validcounter;
                     break;
            case 2:  Pod2 = Pod2 / validcounter;
                     break;
            case 3:  Pod3 = Pod3 / validcounter;;
                     break;
     }
     Off(OUT_BC);
     TR45();
}
byte smuxStatuss(byte smux)
{
     byte sendMsg[2];
     byte readMsg[1];
     int status = 0;
     const byte count = 1;
     
     sendMsg[0] = 0x10;
     sendMsg[1] = 0x21;
     
     if(I2CBytes(smux,sendMsg,count,readMsg))
     {
         return readMsg[0];
     }
     else
     {
         return -1;
     }
}
task main()
{
     InitSensors();
     StartTiming();
     TextOut(0,LCD_LINE2,"fick dich nochmal Flo");
     LongLine();
     GreenAttempts = 0;
     Ultrasonicvalue = 0;
     downFloor = false;
     while(downFloor)
     {

          HandleCounting(); //Ticks the smux delayer
          CheckForLongSync();
          SpeedLeft = Speednorm;
          SpeedRight = Speednorm;
          time = ReturnTime();
          ClearScreen();
          NumOut(0,LCD_LINE1,ReturnSensorTime());
          NumOut(0, LCD_LINE2, SENSOR_2);
          NumOut(0, LCD_LINE3, SENSOR_3);
          NumOut(0, LCD_LINE4, GreenAttempts);
          NumOut(0, LCD_LINE5, SENSOR_4);
           NumOut(0,LCD_LINE7,x);
          ReadUltrasonic();

          if(Ultrasonicvalue > 0)
          {
          NumOut(0, LCD_LINE6, Ultrasonicvalue);
          }

          if(ReadFrontTouch())
          {
              TextOut(0, LCD_LINE6, "Touch");
          }

          if(SENSOR_2 < Schwarzwert)
          {
              TurnRight();
          }
          if((SENSOR_3 < Schwarzwert) && (ReturnSensorTime() > stime))
          {
              TurnLeft();
          }

          if((time > 1000) && (ReturnSensorTime() > stime))
          {
              if(DirectionRight == true)
              {
                  SpeedLeft = 50;
                  SpeedRight = 30;
              }
              else
              {
                  SpeedLeft = 30;
                  SpeedRight = 50;
              }
          }
          // Wenn Silber -> Ausrichten
          if(SENSOR_3 > Silberwert3)
          {
              while((SENSOR_3 < Silberwert3) || (SENSOR_2 < Silberwert2))
              {
                  if(SENSOR_3 < Silberwert3)
                  {
                      OnFwd(OUT_C, -30);
                  }
                  if(SENSOR_2 < Silberwert2)
                  {
                      OnFwd(OUT_B, 100);
                  }
              }
              break;
          }
          if(SENSOR_2 > Silberwert2)
          {
              while((SENSOR_3 < Silberwert3) || (SENSOR_2 < Silberwert2))
              {
                  if(SENSOR_2 < Silberwert2)
                  {
                      OnFwd(OUT_B, -30);
                  }
                  if(SENSOR_3 < Silberwert3)
                  {
                      OnFwd(OUT_C, 100);
                  }
              }
              break;
          }
          // Bis hier ausrichten
          OnRev(OUT_A, 70);
          OnFwd(OUT_B, SpeedLeft);
          OnFwd(OUT_C, SpeedRight);
          Wait(20);
          Off(OUT_BC);
     }
     //UpperFloor
     ClearScreen();
     byte status = 0;

     while(true)
     {

         
         //status = smuxStatuss(IN_1);
         //NumOut(0,LCD_LINE1,status);
         //ClearScreen();
         //ReadUltrasonic();
         //NumOut(0,LCD_LINE2, Ultrasonicvalue);
         //Wait(100);

         // Podest suchen
        /* OnFwdReg(OUT_BC, -30, 2);
         Wait(11000);
         Off(OUT_BC);
         checkPods(1);
         NumOut(0,LCD_LINE1,Pod1);
         Wait(30000); */
         /*
         OnRev(OUT_B, 100);
         OnFwd(OUT_C, 100);
         Wait(turntime/2);
         Off(OUT_BC);
         StartUS();
         OnFwdReg(OUT_BC, 30, 2);
         while(ReturnUSTime() <= 30000)
         {
              ReadUltrasonic();
              if(Ultrasonicvalue != 0)
              {
                  ClearScreen();
                  NumOut(0,LCD_LINE2, Ultrasonicvalue);
              }

         }
          /*if(ReadBackLight() > 80)
         {
             Wait(1000);
             Off(OUT_BC);
             OnFwd(OUT_A, -100);
             Wait(1000);
             Off(OUT_A);
         }
         

         //Dose suchen
         NumOut(0, LCD_LINE1, ReadBackLight());
         ReadUltrasonic();
          OnFwdReg(OUT_BC, -30, 2);
         if(Ultrasonicvalue != 0)
         {
              ClearScreen();
              NumOut(0,LCD_LINE2, Ultrasonicvalue);
         }

         if(((Ultrasonicvalue <= 35) && (Ultrasonicvalue != 0)) )
         {

          Off(OUT_ABC);
          OnFwd(OUT_BC,50);
          Wait(3500);
          if(Ultrasonicvalue <= 10)
          {
             OnFwd(OUT_C,50);
             OnRev(OUT_B,50);
             Wait(400);
             Off(OUT_BC);
          }
          if((Ultrasonicvalue > 10) && (Ultrasonicvalue <= 20))
          {
             OnFwd(OUT_C,50);
             OnRev(OUT_B,50);
             Wait(600);
             Off(OUT_BC);
          }
          if(Ultrasonicvalue > 20)
          {
             OnFwd(OUT_C,50);
             OnRev(OUT_B,50);
             Wait(800);
             Off(OUT_BC);
          }

         }
         if(ReadBackLight() > 80)
         {
             Wait(1000);
             Off(OUT_BC);
             OnFwd(OUT_A, -100);
             Wait(1000);
             Off(OUT_A);
         }
          */
     }


}
